### Laboratory Tutorial  
---

Following notes are stolen directly from: http://pages.cs.wisc.edu/~remzi/OSTEP/lab-tutorial.pdf

---
### Compilation Process
```          
source code ---cpp---> source code ---cc1---> assembly code ---as---> object code ---ld---> executable program
            preprocessor             compiler               assembler               linker
```  
* C Pre-processor (cpp)
  - find a particular file and insert into the code at the spot of the `#include`
  - by default `cpp` will look in the directory `/usr/include/`
* Compiler (cc)
* Assembler (as)
* Link-editor or Linker (ld)


### Useful GCC Flags
```bash
# specify the executable name
$ gcc -o example example.c

# get better warnings
$ gcc -Wall example.c

# enable debugging with gdb
$ gcc -g example.c

# turn on optimization
$ gcc -O example.c

# store the usual "temporary" intermediate files permanently
$ gcc -save-temps example.c
```


### Linking with Libraries
#### Using library routine in a program
- Find the right `#include` file  

> How to find right header (`#include`) file for library routine?

Look at _SYNOPSIS_ section in manual pages.  

For example if you want to use fork routine, run `man fork`
```
$ man fork

FORK(2)                     ...

NAME
     fork - create a child process

SYNOPSIS
     #include <unistd.h>   <--- HEADER FILE TO INCLUDE

     pid_t fork(void);
```

If library routine do not reside in C library (`libc`)
```
$ man sin

SIN(3)                                      ...

NAME
       sin, sinf, sinl - sine function

SYNOPSIS
       #include <math.h>  <<<===== HEADER FILE TO INCLUDE

       double sin(double x);
       float sinf(float x);
       long double sinl(long double x);

       Link with -lm. <<<===== HOW TO: “link” your program with the math library
```

#### Standard Location
* Header files: `/usr/include`
* Libraries: `/usr/lib`

#### Types of Libraries
* Statically-linked libraries (which end in `.a`)
  - combined directly into your executable; that is, the low-level code for the library is inserted into your executable by the linker, and results in a much larger binary object.
* Dynamically-linked ones (which end in `.so`)
  - just includes the reference to a library in your program executable; when the program is run, the operating system loader dynamically links in the library.
  - saves disk space (no unnecessarily large executables are made) and allows applications to share library code and static data in memory.

#### How to link library? (specify the library to the link-editor)
```
# link math library
gcc -o executable_name source.c -Wall -lm

# where
-lXXX flag: tells the linker to look for libXXX.so or libXXX.a, probably in that order
```

####  Using headers/libraries that reside in non-standard locations
- want the compiler to search for headers in a different path than the usual places: use the compiler flag `-I/foo/bar` to look for headers in the directory `/foo/bar`.
- want the compiler to link with libraries that you specify: use `-L/foo/bar` flag to look for libraries in the `/foo/bar` directory.  
- one common directory to specify in this manner is “.” (called “dot”), which is UNIX shorthand for the current directory.  
- the -I flag should go on a compile line, and the -L flag on the
link line.


### Separate Compilation

```
# Before
├── helpers.c
├── include
│   └── helpers.h
└── myapp.c

$ gcc -c helpers.c -Wall -Werror -I./include  
$ gcc -c myapp.c -Wall -Werror -I./include/
$ gcc -o iapp helpers.o myapp.o

# After
├── helpers.c
├── helpers.o
├── iapp
├── include
│   └── helpers.h
├── myapp.c
└── myapp.o


# where:
- The -c flag tells the compiler just to produce an object file.
```


### Makefiles
- The program `make` lets you automate much of your build process.
- for example:

```makefile
iapp: helpers.o myapp.o
        gcc -o iapp helpers.o myapp.o

helpers.o: helpers.c
        gcc -c helpers.c -Wall -Werror -I/home/sushant/learn-cpp/build-things/include

myapp.o: myapp.c
        gcc -c myapp.c -Wall -Werror -I/home/sushant/learn-cpp/build-things/include/ -std=c99

clean:
        rm -f helpers.o myapp.o iapp
```

- Makefiles are based on rules, which are used to decide what needs to
happen. The general form of a rule:

```makefile
target: prerequisite1 prerequisite2 ...
    command1
    command2
      ...
```

- **target**: is usually the name of a file that is generated by a program;
examples of targets are executable or object files. A target can also be the name of an action to carry out, such as “clean” in our example.

- **prerequisite**: is a file that is used as input to create the target. A
target often depends on several files. For example, to build the executable
iapp, we need two object files to be built first: helpers.o and myapp.o.

- **command**: is an action that make carries out. A rule may have
more than one command, each on its own line.
  * Important: You have to put a single tab character at the beginning of every command line! If you just put spaces, make will print out some obscure error message and exit.

- Note: Usually a command is in a rule with prerequisites and serves to create a target file if any of the prerequisites change. However, the rule that specifies commands for the target need not have prerequisites. For example, the rule containing the delete command associated with the target “clean” does not have prerequisites.

##### Nicer Makefiles
For example:
```makefile
# specify all source files here
SRCS = myapp.c helpers.c

# specify target here (name of executable)
TARG = iapp2

# specify compiler, compile flags, and needed libs
CC = gcc
OPTS = -Wall -O
LIBS = -lm

# this translates .c files in src list to .o’s
OBJS = $(SRCS:.c=.o)

# all is not really needed, but is used to generate the target
all: $(TARG)

# this generates the target executable
$(TARG): $(OBJS)
        $(CC) -o $(TARG) $(OBJS) $(LIBS)

# this is a generic rule for .o files
%.o: %.c
        $(CC) $(OPTS) -c $< -o $@

# and finally, a clean line
clean:
        rm -f $(OBJS) $(TARG)
```
It allows you to easily add new source files into your build, simply by adding them to the SRCS variable at the top of the makefile. You can also easily change the name of the executable by changing the TARG line, and the compiler, flags, and library specifications are all easily modified.


### Documentation

```
# to search the man pages for keywords
make -k <keyword>

# look for man page in particular section
man <section-number> <search-term>

  The table below shows the section numbers of the manual followed by the types of pages they contain.
       1   Executable programs or shell commands
       2   System calls (functions provided by the kernel)
       3   Library calls (functions within program libraries)
       4   Special files (usually found in /dev)
       5   File formats and conventions eg /etc/passwd
       6   Games
       7   Miscellaneous (including macro packages and conventions), e.g. man(7), groff(7)
       8   System administration commands (usually only for root)
       9   Kernel routines [Non standard]

# cycle through different sections of man pages
man -a <search-term>
```

Man pages are useful for finding out a number of things. In particular, you will often want to look up what arguments to pass to a library call, or what header files need to be included to use a library call. All of this should be available in the man page.
For example, if you look up the open() system call, you will see:

```
$ man 2 open

OPEN(2)                             ....
NAME
       open, openat, creat - open and possibly create a file

SYNOPSIS
       #include <sys/types.h>
       #include <sys/stat.h>
       #include <fcntl.h>

       int open(const char *pathname, int flags);
       int open(const char *pathname, int flags, mode_t mode);

       int creat(const char *pathname, mode_t mode);

       int openat(int dirfd, const char *pathname, int flags);
       int openat(int dirfd, const char *pathname, int flags, mode_t mode);
          .
          .
          .
RETURN VALUE
       open(), openat(), and creat() return the new file descriptor, or -1 if an error occurred (in which  case,  errno  is  set  appropri‐
       ately).

ERRORS
       open(), openat(), and creat() can fail with the following errors:

       EACCES The requested access to the file is not allowed, or search permission is denied for one of the directories in the path prefix
              of pathname, or the file did not exist yet and write access to the parent directory is not allowed.  (See  also  path_resolu‐
              tion(7).)
        ...
```


> To look for the definition of a structure that is not specified in the man page itself

`gcc -E main.c`  - The result of this is a C file that has all of the needed structures and prototypes in it.


### Misc Notes:
- The Glibc package contains the main C library. This library provides the basic routines for allocating memory, searching directories, opening and closing files, reading and writing files, string handling, pattern matching, arithmetic, and so on.


